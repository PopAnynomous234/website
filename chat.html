<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="st.css">
    <link rel="stylesheet" href="styles.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COdelistener Chat</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <style>
        /* Startup Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a2e; /* Very dark background */
            color: #e0e0e0; /* Light text color for contrast */
            display: flex;
            gap: 20px;
            min-height: 100vh;
        }

        #app-container {
            display: flex;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Darker shadow */
            background-color: #2e004a; /* Darker distinct background */
            animation: slideInUp 0.8s ease-out forwards, fadeIn 0.8s ease-out forwards; /* Startup animations */
            opacity: 0; /* Start invisible for animation */
        }

        #sidebar {
            width: 250px;
            background-color: #06120C; /* Dark blue background */
            padding: 20px;
            border-right: 1px solid #0f3460; /* Darker border */
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #main-chat {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            background-color: black; /* Slightly different dark purple */
        }

        h2, h3 {
            color: #e0e0e0; /* Light color for headers */
            margin-top: 0;
            margin-bottom: 10px;
        }

        #username-display {
            font-weight: bold;
            color: #26ff9a; /* Accent color */
            margin-bottom: 10px;
        }

        .online-users {
            font-size: 0.9em;
            color: #26ff9a; /* Accent color for online users */
            font-weight: bold;
            margin-bottom: 15px;
        }

        .room-item {
            padding: 8px 12px;
            border-radius: 5px;
            margin-bottom: 5px;
            background-color: #16213e; /* Dark blue background */
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-item.active, .room-item:hover {
            background-color: #0f3460; /* Darker blue on hover/active */
        }

        .room-item span {
            font-weight: bold;
            color: #e0e0e0; /* Light text color */
        }

        .room-item-actions button {
            background: none;
            border: none;
            color: #26ff9a; /* Accent color for action buttons */
            padding: 0 5px;
            cursor: pointer;
            font-size: 0.8em;
            transition: color 0.2s ease;
        }
        .room-item-actions button.delete-room-btn {
            color: #ff4d4d; /* Red for delete button */
        }
        .room-item-actions button:hover {
            color: #1ac77f;
        }
        .room-item-actions button.delete-room-btn:hover {
            color: #cc0000;
        }


        form {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        input[type="text"], input[type="password"], textarea {
            padding: 10px;
            border: 1px solid #0f3460; /* Darker border */
            border-radius: 4px;
            font-size: 1em;
            width: 100%;
            box-sizing: border-box;
            background-color: #1a1a2e; /* Dark input background */
            color: #e0e0e0; /* Light text color */
        }

        button {
            padding: 10px 15px;
            background-color: #26ff9a; /* Accent color for buttons */
            color: #1a1a2e; /* Dark text on accent button */
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }

        button:hover {
            background-color: #1ac77f; /* Slightly darker accent on hover */
        }

        #messages-container {
            flex-grow: 1;
            border: 1px solid #0f3460; /* Darker border */
            border-radius: 4px;
            padding: 15px;
            overflow-y: auto;
            margin-bottom: 15px;
            background-color: #1a1a2e; /* Dark background for messages area */
        }

        .message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 8px;
            background:transparent; /* Dark blue message bubble */
            word-wrap: break-word;
        }

        .message.mine {
            background:transparent; /* Even darker blue for own messages */
            text-align: right;
            margin-left: auto;
        }

        .message .sender {
            font-weight: bold;
            color: #26ff9a; /* Accent color for sender */
            margin-bottom: 5px;
            display: block;
        }

        .message.mine .sender {
            color: #26ff9a; /* Accent color for own sender */
        }

        .message .timestamp {
            font-size: 0.8em;
            color: #a0a0a0; /* Muted timestamp color */
            margin-top: 5px;
            display: block;
        }

        .message .text {
            white-space: pre-wrap; /* Preserve newlines */
            color: #e0e0e0; /* Light text */
        }

        .message .actions button {
            background: none;
            color: #26ff9a; /* Accent color for action buttons */
            border: none;
            padding: 0 5px;
            font-size: 0.85em;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .message .actions button:hover {
            color: #1ac77f; /* Slightly darker accent on hover */
        }

        .message .reply-context {
            background-color: #0d284a; /* Darker background for reply context */
            border-left: 3px solid #26ff9a; /* Accent border */
            padding: 5px 10px;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #e0e0e0; /* Light text color */
            border-radius: 4px;
        }

        #message-input-area {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #message-input-area textarea {
            flex-grow: 1;
            resize: vertical;
            min-height: 40px;
            max-height: 150px;
        }

        #replying-to {
            background-color: #0f3460; /* Dark blue background */
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 10px;
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: space-between;
        }

        #replying-to span {
            font-style: italic;
            color: #e0e0e0; /* Light text */
        }

        #replying-to button {
            background: none;
            color: #ff4d4d; /* Red for cancel */
            border: none;
            padding: 0 5px;
            cursor: pointer;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #app-container {
                flex-direction: column;
            }
            #sidebar {
                width: 100%;
                border-bottom: 1px solid #0f3460; /* Darker border */
                border-right: none;
            }
            #main-chat {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <img src="https://cdn.jsdelivr.net/gh/PopAnynomous234/assets/logo.png" width=70px height=70px alt="logo">
            <ul>
                <li>
                <a href="index.html">
                  <i class="fas fa-home icon"></i>
                  <span class="text">Home</span>
                </a>
              </li>
              <li>
                <a href="ai.html">
                  <i class="fas fa-robot icon"></i>
                  <span class="text">AI</span>
                </a>
              </li>
              <li>
                <a href="tools.html">
                    <i class="fa-solid fa-screwdriver-wrench"></i>
                  <span class="text">Tools</span>
                </a>
              </li>
              <li>
                <a href="games.html">
                  <i class="fas fa-gamepad icon"></i>
                  <span class="text">Games</span>
                </a>
              </li>
                    <li>
                <a href="music.html">
                  <i class="fas fa-music icon"></i>
                  <span class="text">Music</span>
                </a>
              </li>
                      <li>
                <a href="chat.html">
                  <i class="fa-regular fa-comment icon"></i>
                  <span class="text">Chat</span>
                </a>
              </li>
              <li>
                <a href="settings.html">
                  <i class="fas fa-cog icon"></i>
                  <span class="text">Settings</span>
                </a>
              </li>
            </ul>
          </div>
    <div id="app-container">
        <div id="sidebar">
            <h2>Codelistener Chat</h2>
            <div id="username-display"></div>
            <div id="online-users-count" class="online-users"></div>

            <h3>Rooms</h3>
            <div id="room-list">
                <!-- Public channel will be injected here -->
            </div>

            <h3>Create Private Room</h3>
            <form id="create-room-form">
                <input type="text" id="new-room-name" placeholder="Room Name" required>
                <button type="submit">Create Room</button>
            </form>

            <h3>Join Private Room</h3>
            <form id="join-room-form">
                <input type="text" id="join-room-code" placeholder="Join Code" required>
                <button type="submit">Join Room</button>
            </form>
        </div>

        <div id="main-chat">
            <h2 id="current-room-name"></h2>
            <div id="messages-container">
                <!-- Messages will be injected here -->
            </div>

            <div id="replying-to">
                <span>Replying to: <strong id="reply-context-text"></strong></span>
                <button id="cancel-reply">X</button>
            </div>

            <div id="message-input-area">
                <textarea id="message-input" placeholder="Send Message . Shift+ Enter for new line"></textarea>
                <button id="send-button">Send</button>
            </div>
        </div>
    </div>

    <script>
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyAd-PM5QNtYuisjKCODf1iPk7OkhyCUaw4",
  authDomain: "c0delistener.firebaseapp.com",
  databaseURL: "https://c0delistener-default-rtdb.firebaseio.com",
  projectId: "c0delistener",
  storageBucket: "c0delistener.firebasestorage.app",
  messagingSenderId: "124624934976",
  appId: "1:124624934976:web:68ed31a7ad0a89e90827a5",
  measurementId: "G-67JPFPJLS4"
};

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // === Global Variables ===
        let currentUser = '';
        let currentRoomId = 'public_channel'; // Default to a public channel
        let currentRoomRef = null;
        let messagesRef = null;
        let presenceRef = null;
        let replyingToMessage = null; // Stores message data being replied to
        let roomsListenerRef = null; // To manage the rooms listener
        const roomElements = new Map(); // Store room ID -> DOM element for efficient updates

        // === DOM Elements ===
        const usernameDisplay = document.getElementById('username-display');
        const onlineUsersCountElem = document.getElementById('online-users-count');
        const roomListElem = document.getElementById('room-list');
        const createRoomForm = document.getElementById('create-room-form');
        const newRoomNameInput = document.getElementById('new-room-name');
        const joinRoomForm = document.getElementById('join-room-form');
        const joinRoomCodeInput = document.getElementById('join-room-code');
        const currentRoomNameElem = document.getElementById('current-room-name');
        const messagesContainer = document.getElementById('messages-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const replyingToElem = document.getElementById('replying-to');
        const replyContextTextElem = document.getElementById('reply-context-text');
        const cancelReplyButton = document.getElementById('cancel-reply');

        // === Utility Functions ===
        function getOrCreateUsername() {
            let storedUsername = localStorage.getItem('chatUsername');
            if (!storedUsername) {
                while (!storedUsername || storedUsername.trim() === '') { // Keep prompting until a non-empty name is given
                    storedUsername = prompt("Please enter your chat username:");
                }
                localStorage.setItem('chatUsername', storedUsername);
            }
            return storedUsername;
        }

        function formatTimestamp(timestamp) {
            if (!timestamp) return 'n/a';
            const date = new Date(timestamp);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) + ' ' +
                   date.toLocaleDateString([], { month: 'short', day: 'numeric' });
        }

        function generateJoinCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        // === Message Display and Actions ===
        function createMessageElement(messageId, messageData) {
            const messageElem = document.createElement('div');
            messageElem.className = 'message';
            messageElem.dataset.id = messageId;

            if (messageData.sender === currentUser) {
                messageElem.classList.add('mine');
            }

            let replyContextHtml = '';
            if (messageData.replyToMessageId && messageData.replyToMessageText) {
                replyContextHtml = `
                    <div class="reply-context">
                        Replying to ${messageData.replyToMessageSender}: "${messageData.replyToMessageText.substring(0, 50)}${messageData.replyToMessageText.length > 50 ? '...' : ''}"
                    </div>
                `;
            }

            const actionsHtml = (messageData.sender === currentUser) ? `
                <div class="actions">
                    <button class="edit-btn">Edit</button>
                    <button class="delete-btn">Delete</button>
                    <button class="reply-btn">Reply</button>
                </div>
            ` : `
                <div class="actions">
                    <button class="reply-btn">Reply</button>
                </div>
            `;


            messageElem.innerHTML = `
                ${replyContextHtml}
                <span class="sender">${messageData.sender}</span>
                <div class="text">${messageData.text}</div>
                <span class="timestamp">${formatTimestamp(messageData.timestamp)}</span>
                ${actionsHtml}
            `;

            // Add event listeners for buttons
            if (messageData.sender === currentUser) {
                messageElem.querySelector('.edit-btn').addEventListener('click', (e) => { e.stopPropagation(); editMessage(messageId, messageData); });
                messageElem.querySelector('.delete-btn').addEventListener('click', (e) => { e.stopPropagation(); deleteMessage(messageId); });
            }
            // All messages can be replied to
            messageElem.querySelector('.reply-btn').addEventListener('click', (e) => { e.stopPropagation(); startReply(messageId, messageData.sender, messageData.text); });

            return messageElem;
        }

        function deleteMessage(messageId) {
            if (confirm("Are you sure you want to delete this message?")) {
                database.ref(`rooms/${currentRoomId}/messages/${messageId}`).remove()
                    .catch(error => console.error("Error deleting message:", error));
            }
        }

        function editMessage(messageId, originalMessageData) {
            const newText = prompt("Edit your message:", originalMessageData.text);
            if (newText !== null && newText.trim() !== '' && newText !== originalMessageData.text) {
                database.ref(`rooms/${currentRoomId}/messages/${messageId}`).update({
                    text: newText,
                    edited: true // Optional: Add an edited flag
                })
                .catch(error => console.error("Error editing message:", error));
            }
        }

        function startReply(messageId, sender, text) {
            replyingToMessage = { id: messageId, sender: sender, text: text };
            replyContextTextElem.textContent = `${sender}: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`;
            replyingToElem.style.display = 'flex';
            messageInput.focus();
        }

        function cancelReply() {
            replyingToMessage = null;
            replyingToElem.style.display = 'none';
            replyContextTextElem.textContent = '';
        }

        // === Room Management (Display, Edit, Delete) ===
        function createOrUpdateRoomElement(room) {
            // Ensure room has valid ID and name before displaying
            if (!room || !room.id || !room.name) {
                console.warn("Attempted to display an invalid room:", room);
                return;
            }

            let roomItem = roomElements.get(room.id);
            if (!roomItem) {
                roomItem = document.createElement('div');
                roomItem.className = 'room-item';
                roomItem.dataset.id = room.id;
                roomElements.set(room.id, roomItem); // Store reference
                roomListElem.appendChild(roomItem);
            }

            let roomNameSpan = document.createElement('span');
            roomNameSpan.textContent = room.name;
            if (room.type === 'private' && room.joinCode) {
                roomNameSpan.textContent += ` (Code: ${room.joinCode})`;
            }

            let actionButtonsDiv = document.createElement('div');
            actionButtonsDiv.className = 'room-item-actions';

            // Only show edit/delete if current user is the owner
            if (room.owner === currentUser) {
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent switchRoom from being called
                    editRoomName(room.id, room.name);
                });
                actionButtonsDiv.appendChild(editBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.className = 'delete-room-btn';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent switchRoom from being called
                    deleteRoom(room.id, room.name);
                });
                actionButtonsDiv.appendChild(deleteBtn);
            }

            // Clear existing content and append new
            roomItem.innerHTML = '';
            roomItem.appendChild(roomNameSpan);
            roomItem.appendChild(actionButtonsDiv);

            // Attach click listener to the whole room item (excluding action buttons)
            roomItem.addEventListener('click', () => switchRoom(room.id, room.name));

            // Update active state
            if (room.id === currentRoomId) {
                roomItem.classList.add('active');
            } else {
                roomItem.classList.remove('active');
            }
        }

        async function editRoomName(roomId, currentName) {
            const newName = prompt(`Enter new name for room "${currentName}":`, currentName);
            if (newName !== null && newName.trim() !== '' && newName !== currentName) {
                try {
                    await database.ref(`rooms/${roomId}`).update({ name: newName });
                    alert(`Room name updated to "${newName}".`);
                } catch (error) {
                    console.error("Error updating room name:", error);
                    alert("Failed to update room name.");
                }
            }
        }

        async function deleteRoom(roomId, roomName) {
            if (confirm(`Are you sure you want to delete the room "${roomName}" and all its messages? This cannot be undone.`)) {
                try {
                    await database.ref(`rooms/${roomId}`).remove();
                    alert(`Room "${roomName}" deleted.`);
                    // If the deleted room was the current room, switch to public
                    if (currentRoomId === roomId) {
                        switchRoom('public_channel', 'Public Channel');
                    }
                    // The 'child_removed' listener in fetchAndDisplayRooms will handle updating the UI
                } catch (error) {
                    console.error("Error deleting room:", error);
                    alert("Failed to delete room.");
                }
            }
        }

        async function switchRoom(newRoomId, newRoomName) {
            // Detach previous message and presence listeners
            if (messagesRef) {
                messagesRef.off();
            }
            if (presenceRef && currentUser) {
                // Remove user's presence from the old room immediately
                presenceRef.child(currentUser).remove();
                presenceRef.off(); // Detach presence listener for the old room
            }

            // Reset UI
            messagesContainer.innerHTML = '';
            cancelReply();
            
            // Set new current room
            currentRoomId = newRoomId;
            currentRoomNameElem.textContent = newRoomName;

            // Update active room in sidebar
            roomElements.forEach(roomItem => {
                if (roomItem.dataset.id === newRoomId) {
                    roomItem.classList.add('active');
                } else {
                    roomItem.classList.remove('active');
                }
            });

            // Set up new room references
            currentRoomRef = database.ref(`rooms/${currentRoomId}`);
            messagesRef = currentRoomRef.child('messages');
            presenceRef = currentRoomRef.child('presence');

            // --- Set up Presence for the NEW room ---
            if (currentUser) {
                const userPresenceRef = presenceRef.child(currentUser);
                userPresenceRef.set(true); // Mark user as online
                userPresenceRef.onDisconnect().remove(); // Remove when user disconnects
            }

            // Listen for changes in online users in the NEW room
            presenceRef.on('value', snapshot => {
                const onlineUsers = snapshot.val();
                const count = onlineUsers ? Object.keys(onlineUsers).length : 0;
                onlineUsersCountElem.textContent = `Online: ${count} (${currentRoomNameElem.textContent})`;
            });

            // --- Listen for Messages in the NEW room ---
            messagesRef.on('child_added', snapshot => {
                const messageId = snapshot.key;
                const messageData = snapshot.val();
                const messageElem = createMessageElement(messageId, messageData);
                messagesContainer.appendChild(messageElem);
                messagesContainer.scrollTop = messagesContainer.scrollHeight; // Scroll to bottom
            });

            messagesRef.on('child_changed', snapshot => {
                const messageId = snapshot.key;
                const messageData = snapshot.val();
                const existingMessageElem = messagesContainer.querySelector(`[data-id="${messageId}"]`);
                if (existingMessageElem) {
                    // Update the text and timestamp or re-create
                    const updatedElem = createMessageElement(messageId, messageData);
                    existingMessageElem.replaceWith(updatedElem);
                }
            });

            messagesRef.on('child_removed', snapshot => {
                const messageId = snapshot.key;
                const existingMessageElem = messagesContainer.querySelector(`[data-id="${messageId}"]`);
                if (existingMessageElem) {
                    existingMessageElem.remove();
                }
            });
        }

        // === Event Listeners ===
        createRoomForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const roomName = newRoomNameInput.value.trim();
            if (roomName) {
                const newRoomRef = database.ref('rooms').push();
                const joinCode = generateJoinCode();
                const roomId = newRoomRef.key;
                await newRoomRef.set({
                    id: roomId,
                    name: roomName,
                    type: 'private',
                    joinCode: joinCode,
                    owner: currentUser, // NEW: Store the owner
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                });
                // Add the creator as a member of the private room
                await database.ref(`rooms/${roomId}/members/${currentUser}`).set(true);

                newRoomNameInput.value = '';
                alert(`Private room "${roomName}" created! Join code: ${joinCode}`);
                // fetchAndDisplayRooms() will re-run and add it
                switchRoom(roomId, roomName); // Switch to the newly created room
            }
        });

        joinRoomForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const code = joinRoomCodeInput.value.trim().toUpperCase();
            if (code) {
                const roomsSnapshot = await database.ref('rooms').orderByChild('joinCode').equalTo(code).once('value');
                const rooms = roomsSnapshot.val();
                if (rooms) {
                    const roomId = Object.keys(rooms)[0];
                    const roomData = rooms[roomId];
                    
                    // Add the joining user as a member
                    await database.ref(`rooms/${roomId}/members/${currentUser}`).set(true);

                    alert(`Joined private room: ${roomData.name}`);
                    joinRoomCodeInput.value = '';
                    fetchAndDisplayRooms(); // Refresh room list after joining
                    switchRoom(roomId, roomData.name); // Switch to the joined room
                } else {
                    alert('Invalid join code.');
                }
            }
        });

        sendButton.addEventListener('click', async () => {
            const messageText = messageInput.value.trim();
            if (messageText) {
                const newMessage = {
                    sender: currentUser,
                    text: messageText,
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                    edited: false
                };

                if (replyingToMessage) {
                    newMessage.replyToMessageId = replyingToMessage.id;
                    newMessage.replyToMessageSender = replyingToMessage.sender;
                    newMessage.replyToMessageText = replyingToMessage.text;
                }

                try {
                    await messagesRef.push(newMessage);
                    messageInput.value = '';
                    cancelReply(); // Clear reply context after sending
                } catch (error) {
                    console.error("Error sending message:", error);
                    alert("Failed to send message.");
                }
            }
        });

        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) { // Send on Enter, allow Shift+Enter for newline
                e.preventDefault();
                sendButton.click();
            }
        });

        cancelReplyButton.addEventListener('click', cancelReply);

        // === Initialization ===
        async function fetchAndDisplayRooms() {
            // First, detach any existing listeners on the rooms reference
            if (roomsListenerRef) {
                roomsListenerRef.off();
            }
            roomListElem.innerHTML = ''; // Clear existing rooms to avoid duplicates on refresh
            roomElements.clear(); // Clear the map of stored room elements

            const publicChannelId = 'public_channel';
            const publicChannelRef = database.ref(`rooms/${publicChannelId}`);
            const publicChannelSnapshot = await publicChannelRef.once('value');
            if (!publicChannelSnapshot.exists() || !publicChannelSnapshot.val().name) {
                await publicChannelRef.set({
                    id: publicChannelId,
                    name: 'Public Channel',
                    type: 'public',
                    owner: 'system', // Public channel has a system owner
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                });
            }
            // Always display the public channel
            createOrUpdateRoomElement({ id: publicChannelId, name: 'Public Channel', type: 'public', owner: 'system' });

            // Now, set up the listener for other rooms and store its reference
            roomsListenerRef = database.ref('rooms').orderByChild('createdAt');
            roomsListenerRef.on('child_added', async snapshot => {
                const room = snapshot.val();
                
                if (!room || !room.id || !room.name) {
                    console.warn("Invalid room data encountered:", room);
                    return;
                }

                if (room.id === publicChannelId) {
                    return; // Public channel is already displayed
                }

                if (room.type === 'private') {
                    // Check if current user is a member of this private room
                    const memberSnapshot = await database.ref(`rooms/${room.id}/members/${currentUser}`).once('value');
                    if (memberSnapshot.exists() && memberSnapshot.val() === true) {
                        createOrUpdateRoomElement(room);
                    }
                } else {
                    // For any other room type (e.g., future public rooms, though currently only one public)
                    createOrUpdateRoomElement(room);
                }
            });

            roomsListenerRef.on('child_changed', async snapshot => {
                const room = snapshot.val();
                 if (!room || !room.id || !room.name) {
                    console.warn("Invalid room data changed:", room);
                    return;
                }
                // If it's a private room, re-check membership before updating display
                if (room.type === 'private') {
                    const memberSnapshot = await database.ref(`rooms/${room.id}/members/${currentUser}`).once('value');
                    if (memberSnapshot.exists() && memberSnapshot.val() === true) {
                        createOrUpdateRoomElement(room);
                    } else {
                        // If user is no longer a member, remove from list
                        const roomElement = roomElements.get(room.id);
                        if (roomElement) {
                            roomElement.remove();
                            roomElements.delete(room.id);
                        }
                    }
                } else {
                    createOrUpdateRoomElement(room);
                }
            });
            
            // Listener for rooms being removed
            roomsListenerRef.on('child_removed', snapshot => {
                const roomRemovedId = snapshot.key;
                const roomElement = roomElements.get(roomRemovedId);
                if (roomElement) {
                    roomElement.remove(); // Remove from DOM
                    roomElements.delete(roomRemovedId); // Remove from map
                }
                // If the deleted room was the current room, switch to public
                if (currentRoomId === roomRemovedId) {
                    switchRoom(publicChannelId, 'Public Channel');
                }
            });
        }


        window.onload = () => {
            currentUser = getOrCreateUsername();
            usernameDisplay.textContent = `Username: ${currentUser}`;
            fetchAndDisplayRooms();
            // Initially switch to the public channel
            switchRoom('public_channel', 'Public Channel');
        };
    </script>
<script src="era4.js"></script>
<script src="era5.js"></script>
<script src="pe.js"></script>
<script src="warn.js"></script>
<script src="cursor.js"></script>
<script src="widget.js"></script>

</body>
</html>
