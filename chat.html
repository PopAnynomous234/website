

<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="st.css">
    <link rel="stylesheet" href="styles.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codelistener Chat</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Scripts -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-check-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@fingerprintjs/fingerprintjs@3/dist/fp.min.js"></script>
    <style>
        /* Startup Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 0.8; }
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 0.8;
                transform: translateY(0);
            }
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: black;
            color: #e0e0e0; /* Light text color for contrast */
            display: flex;
            gap: 20px;
            height:700px;
        }

        #app-container {
            border:2px solid #26ff9a;
            display: flex;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Darker shadow */
            background-color: black; /* Darker distinct background */
            animation: slideInUp 0.8s ease-out forwards, fadeIn 0.8s ease-out forwards; /* Startup animations */
            opacity: 0; /* Start invisible for animation */
        }

        #sidebar {
            width: 250px;
            background-color: #06120C;
            padding: 20px;
            display: flex;
            overflow:scroll;
            flex-direction: column;
            gap: 15px;
        }

        #main-chat {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            background-color: black; /* Slightly different dark purple */
        }

        h2, h3 {
            color: #e0e0e0; /* Light color for headers */
            margin-top: 0;
            margin-bottom: 10px;
        }

        #username-display {
            font-weight: bold;
            color: #26ff9a; /* Accent color */
            margin-bottom: 10px;
        }

        .online-users {
            font-size: 0.9em;
            color: #26ff9a; /* Accent color for online users */
            font-weight: bold;
            margin-bottom: 15px;
        }

        .room-item {
            padding: 8px 12px;
            border-radius: 5px;
            margin-bottom: 5px;
            background-color: #1BB66E; /* Dark blue background */
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .room-item.active {
            background-color:#093E25;
        }

        .room-item span {
            font-weight: bold;
            color: #e0e0e0; /* Light text color */
        }

        .room-item-actions button {
            background: none;
            border: none;
            color: #26ff9a; /* Accent color for action buttons */
            padding: 0 5px;
            cursor: pointer;
            font-size: 0.8em;
            transition: color 0.2s ease;
        }
        .room-item-actions button.delete-room-btn {
            color: #ff4d4d; /* Red for delete button */
        }
        .room-item-actions button:hover {
            color: #1ac77f;
        }
        .room-item-actions button.delete-room-btn:hover {
            color: #cc0000;
        }


        form {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        input[type="text"], input[type="password"], textarea {
            padding: 10px;
            border: 1px solid #26ff9a; /* Darker border */
            border-radius: 4px;
            font-size: 1em;
            width: 100%;
            box-sizing: border-box;
            background-color: #03160D ; /* Dark input background */
            color: #26ff9a; /* Light text color */
        }

        button {
            padding: 10px 15px;
            background-color: #26ff9a; /* Accent color for buttons */
            color: #1a1a2e; /* Dark text on accent button */
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }

        button:hover {
            background-color: #1ac77f; /* Slightly darker accent on hover */
        }

        #messages-container {
            flex-grow: 1;
            border: 1px solid #03160D; /* Darker border */
            border-radius: 4px;
            padding: 15px;
overflow-y: scroll !important; /* Force Windows to render the track */
    -webkit-overflow-scrolling: touch; 
    display: block;
            margin-bottom: 15px;
            background-color: #0a0a0a; /* Dark background for messages area */
        }

        .message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 8px;
            background:transparent;
            word-wrap: break-word;
        }

        .message.mine {
            text-align: right;
        }
        .message .sender {
            font-weight: bold;
            color: #26ff9a; /* Accent color for sender */
            margin-bottom: 5px;
            display: block;
        }

        .message.mine .sender {
            color: #26ff9a; /* Accent color for own sender */
        }

        .message .timestamp {
            font-size: 0.8em;
            opacity: 0.8;
            color: #a0a0a0; /* Muted timestamp color */
            margin-bottom: 5px;
        }

        .message .text {
            white-space: pre-wrap; /* Preserve newlines */
            color: #e0e0e0; /* Light text */
        }

        .message .actions button {
            background: none;
            color: #26ff9a; /* Accent color for action buttons */
            border: none;
            padding: 0 5px;
            font-size: 0.85em;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .message .actions button:hover {
            color: #1ac77f; /* Slightly darker accent on hover */
        }

        .message .reply-context {
            background-color: #00160E; /* Darker background for reply context */
            border-left: 3px solid #26ff9a; /* Accent border */
            padding: 5px 10px;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #e0e0e0; /* Light text color */
            border-radius: 4px;
        }
       

        #message-input-area {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #message-input-area textarea {
            flex-grow: 1;
            resize: vertical;
            min-height: 40px;
            max-height: 150px;
        }

        #replying-to {
            background-color: #00160E;
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 10px;
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: space-between;
        }

        #replying-to span {
            font-style: italic;
            color: #e0e0e0; /* Light text */
        }

        #replying-to button {
            background: none;
            color: #ff4d4d; /* Red for cancel */
            border: none;
            padding: 0 5px;
            cursor: pointer;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #app-container {
                flex-direction: column;
            }
            #sidebar {
                width: 100%;
                border-bottom: 1px solid #0f3460; /* Darker border */
                border-right: none;
            }
            #main-chat {
                padding: 15px;
            }
        }
/* The row underneath the bubble */
.message-meta {
    display: flex;
    gap: 5px;
    margin-top:10px;
    font-size: 12px;
    color: #a0a0a0; /* Grey text */
}
.sender {
    font-weight: 500;
}
/* Container alignment for your messages */
.message.mine {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    text-align: right;
}

/* Metadata alignment for your messages */
.message.mine .message-meta {
    justify-content: flex-end; /* Pushes flex items (sender/time) to the right */
    width: 100%;
    display: flex;
    gap: 5px;
}

#typing-indicator {
    height: 20px;
    font-size: 12px;
    color: #8e9297; /* A soft grey */
    padding-left: 10px;
    font-style: italic;
    transition: all 0.2s ease; /* Makes it fade in/out smoothly */
}
/* Container for the dots */
.typing-dots {
    display: inline-flex;
    align-items: center;
    margin-left: 4px;
}

/* Individual dots */
.typing-dots span {
    font-weight: bold;
    font-size: 20px;
    line-height: 10px;
    animation: bounceFade 1.4s infinite both;
}

/* Stagger the dots so they follow each other */
.typing-dots span:nth-child(2) {
    animation-delay: 0.2s;
}

.typing-dots span:nth-child(3) {
    animation-delay: 0.4s;
}

/* The Jump and Fade Animation */
@keyframes bounceFade {
    0%, 80%, 100% {
        opacity: 0.2;
        transform: translateY(0);
    }
    40% {
        opacity: 1;
        transform: translateY(-5px); /* This makes it "jump" */
    }
}

.announcement-style {
    background: linear-gradient(90deg, black, gray) !important;
    color: black !important;
    font-weight: bold !important;
    text-align: center !important;
    width: 100% !important;
    border-radius: 10px;
    padding: 15px !important;
    margin: 20px 0 !important;
    border: 2px solid #000;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}

.announcement-style .message-meta {
    justify-content: center;
}

#visual-coin {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100px;
    height: 100px;
    z-index: 9999;
    perspective: 1000px;
}

.coin-inner {
    width: 100%;
    height: 100%;
    position: relative;
    transition: transform 2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    transform-style: preserve-3d;
    animation: flip-spin 2s forwards;
}

.front, .back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 40px;
    font-weight: bold;
    border-radius: 50%;
    border: 5px solid #d4af37;
    background: radial-gradient(circle, #f1c40f, #d4af37);
    color: white;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
}

.back {
    transform: rotateY(180deg);
}

/* If result is Tails, we add an extra half-turn */
#visual-coin.tails .coin-inner {
    animation: flip-spin-tails 2s forwards;
}

@keyframes flip-spin {
    from { transform: rotateY(0); }
    to { transform: rotateY(1800deg); } /* Spins 5 times and lands on Front */
}

@keyframes flip-spin-tails {
    from { transform: rotateY(0); }
    to { transform: rotateY(1980deg); } /* Spins 5.5 times and lands on Back */
}

.admin-toolbar {
    color:#26ff9a;
}
    </style>
</head>
<body>
    <div class="sidebar">
        <img src="https://cdn.jsdelivr.net/gh/PopAnynomous234/assets/logo.png" width=70px height=70px alt="logo">
            <ul>
                <li>
                <a href="index.html">
                  <i class="fas fa-home icon"></i>
                  <span class="text">Home</span>
                </a>
              </li>
              <li>
                <a href="ai.html">
                  <i class="fas fa-robot icon"></i>
                  <span class="text">AI</span>
                </a>
              </li>
              <li>
                <a href="tools.html">
                    <i class="fa-solid fa-screwdriver-wrench"></i>
                  <span class="text">Tools</span>
                </a>
              </li>
              <li>
                <a href="games.html">
                  <i class="fas fa-gamepad icon"></i>
                  <span class="text">Games</span>
                </a>
              </li>
                    <li>
                <a href="music.html">
                  <i class="fas fa-music icon"></i>
                  <span class="text">Music</span>
                </a>
              </li>
                      <li>
                <a href="chat.html">
                  <i class="fa-regular fa-comment icon"></i>
                  <span class="text">Chat</span>
                </a>
              </li>
              <li>
                <a href="settings.html">
                  <i class="fas fa-cog icon"></i>
                  <span class="text">Settings</span>
                </a>
              </li>
            </ul>
          </div>
         
    <div id="app-container">
        <div id="sidebar">
            <h2>Codelistener Chat</h2>
            <div id="username-display"></div>
            <div id="admin-toolbar" class="admin-toolbar" style="display:none;">
    ‚≠ê SPECIAL PERSON     
</div>
            <button id="change-username-btn" onclick="changeUsername()">Change Name</button>
            <div id="online-users-count" class="online-users"></div>

            <h3>Rooms</h3>
            <div id="room-list">
                <!-- Public channel will be injected here -->
            </div>

            <h3>Create Private Room</h3>
            <form id="create-room-form">
                <input type="text" id="new-room-name" placeholder="Room Name" required>
                <button type="submit">Create Room</button>
            </form>

            <h3>Join Private Room</h3>
            <form id="join-room-form">
                <input type="text" id="join-room-code" placeholder="Join Code" required>
                <button type="submit">Join Room</button>
            </form>
        </div>

        <div id="main-chat">
            <h2 id="current-room-name"></h2>
            <div id="messages-container">
                <!-- Messages will be injected here -->
            </div>
<div id="typing-indicator" style="min-height: 20px; color: #888; font-size: 0.85em; padding: 5px 15px; font-style: italic;"></div>
            <div id="replying-to">
                <span>Replying to: <strong id="reply-context-text"></strong></span>
                <button id="cancel-reply">X</button>
            </div>

            <div id="message-input-area">
                <textarea id="message-input" placeholder="Send Message . Shift+ Enter for new line"></textarea>
                <button id="send-button" style="color:white; background:transparent; rotate: 270deg;">‚å≤</button>
            </div>
        </div>
    </div>
    <script>
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyAd-PM5QNtYuisjKCODf1iPk7OkhyCUaw4",
  authDomain: "c0delistener.firebaseapp.com",
  databaseURL: "https://c0delistener-default-rtdb.firebaseio.com",
  projectId: "c0delistener",
  storageBucket: "c0delistener.firebasestorage.app",
  messagingSenderId: "124624934976",
  appId: "1:124624934976:web:68ed31a7ad0a89e90827a5",
  measurementId: "G-67JPFPJLS4"
};

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

var PROTECTED_NAMES = ["Admin", "Staff", "Moderator", "Codelistener", "Boss", "owner"];

// üîê SECURITY SETTINGS
var SALT = "c9f1e7a4b2d8f6e3";
var ITERATIONS = 100000; 
var HASHED_MASTER_PASSWORD = "e9924cce72737fe77b88325857f5e9de860dcedbde88f1aff9585142e172a54b";

var userPrivileges = "normal";
var deviceFingerprint = ""; // Should be populated by FingerprintJS on load
        // === Global Variables ===
        let currentUser = '';
        let currentRoomId = 'public_channel'; // Default to a public channel
        let currentRoomRef = null;
        let messagesRef = null;
        let typingTimeout = null;
        let unreadCount = 0;
        let presenceRef = null;
        let replyingToMessage = null; // Stores message data being replied to
        let roomsListenerRef = null; // To manage the rooms listener
        const roomElements = new Map(); // Store room ID -> DOM element for efficient updates

        // === DOM Elements ===
        const usernameDisplay = document.getElementById('username-display');
        const onlineUsersCountElem = document.getElementById('online-users-count');
        const roomListElem = document.getElementById('room-list');
        const appCheck = firebase.appCheck();
appCheck.activate(
  new firebase.appCheck.ReCaptchaEnterpriseProvider('6LcDq2EsAAAAAPn2Pah4JM6xxhs-5JsRvYN6hqPJ'),
  true // This 'true' allows the token to refresh automatically
);
        const createRoomForm = document.getElementById('create-room-form');
        const newRoomNameInput = document.getElementById('new-room-name');
        const joinRoomForm = document.getElementById('join-room-form');
        const joinRoomCodeInput = document.getElementById('join-room-code');
        const currentRoomNameElem = document.getElementById('current-room-name');
        const messagesContainer = document.getElementById('messages-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const replyingToElem = document.getElementById('replying-to');
        const replyContextTextElem = document.getElementById('reply-context-text');
        const cancelReplyButton = document.getElementById('cancel-reply');
        const typingIndicatorElem = document.getElementById('typing-indicator');
        const originalTitle = document.title;

function startFingerprint() {
    if (typeof FingerprintJS !== 'undefined') {
        FingerprintJS.load().then(function(fp) {
            fp.get().then(function(result) {
                deviceFingerprint = result.visitorId;
                console.log("Hardware ID Verified: " + deviceFingerprint);
            });
        });
    } else {
        // If it's still missing, we wait 500ms and try again
        console.warn("Library not ready yet, retrying...");
        setTimeout(startFingerprint, 500);
    }
}
async function hashPasswordPBKDF2(password) {

    const enc = new TextEncoder();

    const keyMaterial = await crypto.subtle.importKey(
        "raw",
        enc.encode(password),
        { name: "PBKDF2" },
        false,
        ["deriveBits"]
    );

    const derivedBits = await crypto.subtle.deriveBits(
        {
            name: "PBKDF2",
            salt: enc.encode(SALT),
            iterations: ITERATIONS,
            hash: "SHA-256"
        },
        keyMaterial,
        256
    );

    const hashArray = Array.from(new Uint8Array(derivedBits));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

async function verifyPassword(inputPassword) {
    const hashedInput = await hashPasswordPBKDF2(inputPassword);
    return hashedInput === HASHED_MASTER_PASSWORD;
}

function showLocalSystemMessage(htmlContent, color) {
    const msgElem = document.createElement('div');
    // We only give it the 'mute-alert-log' ID if it's actually a mute message
    if (htmlContent.includes("muted")) {
        msgElem.id = 'mute-alert-log';
    }

    msgElem.style.cssText = `
        text-align: center;
        margin: 15px auto;
        width: 92%;
        padding: 12px;
        border-radius: 8px;
        font-family: 'Courier New', Courier, monospace;
        font-size: 0.85em;
        color: ${color};
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid ${color};
        box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    `;
   
    msgElem.innerHTML = htmlContent;
   
    messagesContainer.appendChild(msgElem);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}
function checkMuteStatus() {
    if (deviceFingerprint) {
        database.ref('hardware_mutes/' + deviceFingerprint).on('value', function(snap) {
            var muteData = snap.val();
            var isMutedNow = muteData && Date.now() < muteData.expiry;

            if (isMutedNow) {
                // Show the red message
                showLocalSystemMessage("SYSTEM: You have been muted by an admin.", "red");
               
                messageInput.placeholder = "You are currently muted.";
                messageInput.disabled = true;
                sendButton.disabled = true;
            } else {
                // --- THE DISAPPEARING ACT ---
                const existingAlert = document.getElementById('mute-alert-log');
                if (existingAlert) {
                    existingAlert.remove(); // This wipes the red text from the screen
                }
               
                messageInput.placeholder = "Type a message...";
                messageInput.disabled = false;
                sendButton.disabled = false;
            }
        });
    }
}
// Add this helper function
function registerUser(name) {
    if (deviceFingerprint !== "" && name !== "") {
        database.ref('registry/' + name).set({
            hardwareId: deviceFingerprint,
            timestamp: Date.now()
        });
    }
}

function showCoinAnimation(result) {
    const coin = document.createElement('div');
    coin.id = 'visual-coin';
    coin.className = result.toLowerCase(); // 'heads' or 'tails'
   
    // Create the "Gold" look
    coin.innerHTML = `
        <div class="coin-inner">
            <div class="front">H</div>
            <div class="back">T</div>
        </div>
    `;
   
    document.body.appendChild(coin);

    // Remove it after the animation ends (3 seconds)
    setTimeout(() => {
        coin.style.opacity = '0';
        setTimeout(() => coin.remove(), 500);
    }, 3000);
}

function sendMessage() {
    var text = messageInput.value.trim();
    if (!text) return;

    // 1. Check for Admin Commands
    if (handleSecretCommands(text)) {
        messageInput.value = '';
        return;
    }

    // 2. The Gatekeeper Check
    if (!deviceFingerprint) {
        alert("Security ID not ready. Please wait a moment.");
        return;
    }

    // 3. Look up the CURRENT user's hardware ID in the mute list
    database.ref('hardware_mutes/' + deviceFingerprint).once('value').then(function(snap) {
        var muteData = snap.val();
        var now = Date.now();

        if (muteData && now < muteData.expiry) {
            // THEY ARE MUTED
            var minsLeft = Math.ceil((muteData.expiry - now) / 60000);
            alert("You are MUTED. Time remaining: " + minsLeft + " minute(s).");
            messageInput.value = ''; // Wipe their message
        } else {
            // THEY ARE NOT MUTED - Send the message now
            database.ref('rooms/' + currentRoomId + '/messages').push({
                sender: currentUser,
                text: text,
                timestamp: now
            }).then(function() {
                messageInput.value = '';
            });
        }
    });
}
function validateAndSetUsername(newName) {
    if (!newName) return false;
    var sanitizedName = newName.trim().replace(/[.#$[\]]/g, '_');
   
    // Check if name is protected
    var isProtected = PROTECTED_NAMES.some(function(n) {
        return n.toLowerCase() === sanitizedName.toLowerCase();
    });

    if (isProtected) {
        var pass = prompt('"' + sanitizedName + '" has Admin Privileges. Password:');
        if (pass === atob(MASTER_KEY_B64)) {
            userPrivileges = "admin";
            if (document.getElementById('admin-toolbar')) {
                document.getElementById('admin-toolbar').style.display = 'block';
            }
            alert("Admin Access Granted.");
        } else {
            alert("Nice try. Access denied for you.");
            return false;
        }
    } else {
        userPrivileges = "normal";
        if (document.getElementById('admin-toolbar')) {
            document.getElementById('admin-toolbar').style.display = 'none';
        }
    }

    // Update Registry in background
    database.ref('registry/' + sanitizedName).set({
        hardwareId: deviceFingerprint,
        timestamp: Date.now()
    }).then(function() {
        console.log("Hardware registered to: " + sanitizedName);
    });

    currentUser = sanitizedName;
    localStorage.setItem('chatUsername', sanitizedName);
    if (document.getElementById('username-display')) {
        document.getElementById('username-display').textContent = "Username: " + currentUser;
    }
   
    return true;
}
function handleSecretCommands(text) {
    if (!text.startsWith('/')) return false;

    var args = text.split(' ');
    var command = args[0].toLowerCase();

    if (userPrivileges !== "admin") {
        alert("Permission denied.");
        return true;
    }

    if (command === '/mute') {

    if (args.length < 2) {
        alert("Usage: /mute Username [minutes]");
        return true;
    }

    // Check if last argument is a number (minutes)
    let mins = 60;
    let lastArg = args[args.length - 1];

    if (!isNaN(parseInt(lastArg))) {
        mins = parseInt(lastArg);
        args.pop(); // remove minutes from array
    }

    // Everything after /mute is the full username
    var targetName = args.slice(1).join(' ').trim();

    if (!targetName) {
        alert("Error: Please specify a username.");
        return true;
    }

    database.ref('registry/' + targetName).once('value').then(function(snap) {
        if (snap.exists()) {
            var hwId = snap.val().hardwareId;
            var expiry = Date.now() + (mins * 60000);

            database.ref('hardware_mutes/' + hwId).set({
                expiry: expiry,
                mutedName: targetName
            }).then(function() {
                alert("SUCCESS: " + targetName + " muted for " + mins + "m");
            });
        } else {
            alert("User '" + targetName + "' not found in registry.");
        }
    });

    return true;
}

    if (command === '/unmute') {

    var target = args.slice(1).join(' ').trim();

    if (!target) {
        alert("Usage: /unmute Username");
        return true;
    }

    database.ref('registry/' + target).once('value').then(function(snap) {
        if (snap.exists()) {
            var hwId = snap.val().hardwareId;
            database.ref('hardware_mutes/' + hwId).remove().then(function() {
                alert(target + " has been unmuted.");
            });
        } else {
            alert("User not found in registry.");
        }
    });

    return true;
}


    if (command === '/whois') {

    var target = args.slice(1).join(' ').trim();

    if (!target) {
        alert("Usage: /whois Username");
        return true;
    }

    database.ref('registry/' + target).once('value').then(function(snap) {
        if (snap.exists()) {
            alert(
                "User: " + target +
                "\nHardware ID: " + snap.val().hardwareId +
                "\nLast Seen: " +
                new Date(snap.val().timestamp).toLocaleString()
            );
        } else {
            alert("No data for user: " + target);
        }
    });

    return true;
}

    // --- NEW: CLEAR CHAT COMMAND ---
    if (command === '/clear') {
        if (confirm("Are you sure you want to wipe all messages in " + currentRoomNameElem.textContent + "?")) {
            // This deletes everything under the current room's messages node
            database.ref('rooms/' + currentRoomId + '/messages').remove().then(function() {
                alert("Chat cleared.");
            }).catch(function(error) {
                console.error("Clear failed: ", error);
            });
        }
        return true;
    }
    if (command === '/announce') {
        var announcementText = args.slice(1).join(' ');
        if (!announcementText) {
            alert("Usage: /announce [your message]");
            return true;
        }

        database.ref('rooms/' + currentRoomId + '/messages').push({
            sender: "üì¢ SYSTEM ANNOUNCEMENT",
            text: announcementText.toUpperCase(),
            timestamp: Date.now(),
            isAnnouncement: true // This is our styling flag
        });
        return true;
    }
    if (command === '/clear-a') {
        database.ref('rooms/' + currentRoomId + '/messages').once('value').then(function(snapshot) {
            snapshot.forEach(function(child) {
                if (child.val().isAnnouncement === true) {
                    child.ref.remove();
                }
            });
            alert("All announcements in this room have been cleared.");
        });
        return true;
    }
    // --- COINFLIP COMMAND ---
    if (command === '/coinflip') {
       const array = new Uint8Array(1);
        window.crypto.getRandomValues(array);
       
        // If the number is 0-127 it's heads, 128-255 it's tails
        const result = array[0] < 128 ? 'HEADS' : 'TAILS';
       
        // 1. Send to Firebase for everyone to see
        database.ref('rooms/' + currentRoomId + '/messages').push({
            sender: "SYSTEM",
            text: `${currentUser} flipped a coin and he got... ${result}!`,
            timestamp: Date.now(),
            isGame: true // Optional flag for styling
        });

        // 2. Trigger the local "Stylish Coin" animation
        showCoinAnimation(result);
        return true;
    }
    // --- HELP COMMAND ---
    if (command === '/help') {
        const helpMenu = `
            <div style="text-align: left; line-height: 1.6;">

                ${userPrivileges === "admin" ? `
                    <hr style="border: 0; border-top: 1px ridge #444; margin: 5px 0;">
                    <strong style="color: #ff4444;">üõ°Ô∏è ADMIN TOOLS</strong><br>
                    <span style="color: #ff4444;">/mute [name] [mins]</span> - Hardware mute<br>
                    <span style="color: #ff4444;">/unmute [name]</span> - Lift mute<br>
                    <span style="color: #ff4444;">/announce [msg]</span> - Global broadcast<br>
                    <span style="color: #ff4444;">/clear</span> - Wipe current room chat<br>
                    <span style="color: #ff4444;">/whois [name]</span> - Get user hardware ID<br>
                    <span style="color: #ff4444;">/coinflip</span> - Flip a coin
                ` : ''}
            </div>
        `;
       
        showLocalSystemMessage(helpMenu, "#ccc");
        return true;
    }
    return false;
}
async function getOrCreateUsername() {

    let storedUsername = localStorage.getItem('chatUsername');

    if (!storedUsername) {

        let name = "";
        while (!name || name.trim() === "") {
            name = prompt("Please enter your chat username:");
        }

        storedUsername = name.trim().replace(/[.#$[\]]/g, '_');
        localStorage.setItem('chatUsername', storedUsername);

        if (typeof database !== 'undefined') {
            database.ref('registry/' + storedUsername).set({
                hardwareId: deviceFingerprint || "pending",
                timestamp: Date.now()
            });
        }
    }

    var isProtected = PROTECTED_NAMES.some(function(n) {
        return n.toLowerCase() === storedUsername.toLowerCase();
    });

    if (isProtected) {

        var alreadyVerified = localStorage.getItem('isAdminVerified') === 'true';

        if (!alreadyVerified) {

            var pass = prompt('"' + storedUsername + '" has Admin Privileges. Password:');

            if (!(await verifyPassword(pass))) {
                alert("Wrong password. Access Denied.");
                localStorage.removeItem('chatUsername');
                location.reload();
                return null;
            }

            localStorage.setItem('isAdminVerified', 'true');
        }

        userPrivileges = "admin";
        localStorage.setItem('isAdmin', 'true');

        const toolbar = document.getElementById('admin-toolbar');
        if (toolbar) toolbar.style.display = 'block';

    } else {

        userPrivileges = "normal";
        localStorage.removeItem('isAdmin');
        localStorage.removeItem('isAdminVerified');

        const toolbar = document.getElementById('admin-toolbar');
        if (toolbar) toolbar.style.display = 'none';
    }

    return storedUsername;
}


async function changeUsername() {

    var newName = prompt("Enter your new username:");
    if (!newName || newName.trim() === "") return;

    var sanitizedName = newName.trim().replace(/[.#$[\]]/g, '_');

    var isProtected = PROTECTED_NAMES.some(function(n) {
        return n.toLowerCase() === sanitizedName.toLowerCase();
    });

    if (isProtected) {

        var pass = prompt('"' + sanitizedName + '" has Admin Privileges. Password:');

        if (!(await verifyPassword(pass))) {
            alert("Wrong password. Get Out!");
            return;
        }

        userPrivileges = "admin";
        localStorage.setItem('isAdmin', 'true');

        if (document.getElementById('admin-toolbar')) {
            document.getElementById('admin-toolbar').style.display = 'block';
        }

    } else {

        userPrivileges = "normal";
        localStorage.removeItem('isAdmin');

        if (document.getElementById('admin-toolbar')) {
            document.getElementById('admin-toolbar').style.display = 'none';
        }
    }

    database.ref('registry/' + sanitizedName).set({
        hardwareId: deviceFingerprint,
        timestamp: Date.now()
    });

    currentUser = sanitizedName;
    localStorage.setItem('chatUsername', sanitizedName);

    if (usernameDisplay)
        usernameDisplay.textContent = "Username: " + currentUser;

    switchRoom(currentRoomId, currentRoomNameElem.textContent);

    alert("Username changed to " + sanitizedName);
}


        function formatTimestamp(timestamp) {
            if (!timestamp) return 'n/a';
            const date = new Date(timestamp);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) + ' ' +
                   date.toLocaleDateString([], { month: 'short', day: 'numeric' });
        }

        function generateJoinCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        // === Message Display and Actions ===
        function createMessageElement(messageId, messageData) {
            const messageElem = document.createElement('div');
            messageElem.className = 'message';
            messageElem.dataset.id = messageId;
messageElem.setAttribute('data-id', messageId);
// Check if it's an announcement
    if (messageData.isAnnouncement) {
        messageElem.classList.add('announcement-style');
    }
            if (messageData.sender === currentUser) {
                messageElem.classList.add('mine');
            }

            let replyContextHtml = '';
            if (messageData.replyToMessageId && messageData.replyToMessageText) {
                replyContextHtml = `
                    <div class="reply-context">
                        Replying to ${messageData.replyToMessageSender}: "${messageData.replyToMessageText.substring(0, 50)}${messageData.replyToMessageText.length > 50 ? '...' : ''}"
                    </div>
                `;
            }

            const actionsHtml = (messageData.sender === currentUser) ? `
                <div class="actions">
                    <button class="edit-btn">‚úé</button>
                    <button class="delete-btn">üóëÔ∏è</button>
                    <button class="reply-btn">‚§∑</button>
                </div>
            ` : `
                <div class="actions">
                    <button class="reply-btn">‚§∑</button>
                </div>
            `;


messageElem.innerHTML = `
    ${replyContextHtml}
    <div class="message-bubble">
        <div class="text">${messageData.text}</div>
    </div>
    <div class="message-meta">
        <span class="sender">${messageData.sender}</span>
        <span class="separator">‚Ä¢</span>
        <span class="timestamp">${formatTimestamp(messageData.timestamp)}</span>
        <span class="actions-container">${actionsHtml}</span>
    </div>
`;

            // Add event listeners for buttons
            if (messageData.sender === currentUser) {
                messageElem.querySelector('.edit-btn').addEventListener('click', (e) => { e.stopPropagation(); editMessage(messageId, messageData); });
                messageElem.querySelector('.delete-btn').addEventListener('click', (e) => { e.stopPropagation(); deleteMessage(messageId); });
            }
            // All messages can be replied to
            messageElem.querySelector('.reply-btn').addEventListener('click', (e) => { e.stopPropagation(); startReply(messageId, messageData.sender, messageData.text); });

            return messageElem;
        }

function deleteMessage(messageId) {
    // This now deletes immediately without asking for permission
    database.ref(`rooms/${currentRoomId}/messages/${messageId}`).remove()
        .then(() => {
            console.log("Message deleted successfully");
        })
        .catch(error => {
            console.error("Error deleting message:", error);
        });
}


        function editMessage(messageId, originalMessageData) {
            const newText = prompt("Edit your message:", originalMessageData.text);
            if (newText !== null && newText.trim() !== '' && newText !== originalMessageData.text) {
                database.ref(`rooms/${currentRoomId}/messages/${messageId}`).update({
                    text: newText,
                    edited: true // Optional: Add an edited flag
                })
                .catch(error => console.error("Error editing message:", error));
            }
        }

        function startReply(messageId, sender, text) {
            replyingToMessage = { id: messageId, sender: sender, text: text };
            replyContextTextElem.textContent = `${sender}: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`;
            replyingToElem.style.display = 'flex';
            messageInput.focus();
        }

        function cancelReply() {
            replyingToMessage = null;
            replyingToElem.style.display = 'none';
            replyContextTextElem.textContent = '';
        }

        // === Room Management (Display, Edit, Delete) ===
        function createOrUpdateRoomElement(room) {
            // Ensure room has valid ID and name before displaying
            if (!room || !room.id || !room.name) {
                console.warn("Attempted to display an invalid room:", room);
                return;
            }

            let roomItem = roomElements.get(room.id);
            if (!roomItem) {
                roomItem = document.createElement('div');
                roomItem.className = 'room-item';
                roomItem.dataset.id = room.id;
                roomElements.set(room.id, roomItem); // Store reference
                roomListElem.appendChild(roomItem);
            }

            let roomNameSpan = document.createElement('span');
            roomNameSpan.textContent = room.name;
            if (room.type === 'private' && room.joinCode) {
                roomNameSpan.textContent += ` (Code: ${room.joinCode})`;
            }

            let actionButtonsDiv = document.createElement('div');
            actionButtonsDiv.className = 'room-item-actions';

            // Only show edit/delete if current user is the owner
            if (room.owner === currentUser) {
                const editBtn = document.createElement('button');
                editBtn.textContent = '‚úé';
                editBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent switchRoom from being called
                    editRoomName(room.id, room.name);
                });
                actionButtonsDiv.appendChild(editBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.className = 'delete-room-btn';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent switchRoom from being called
                    deleteRoom(room.id, room.name);
                });
                actionButtonsDiv.appendChild(deleteBtn);
            }

            // Clear existing content and append new
            roomItem.innerHTML = '';
            roomItem.appendChild(roomNameSpan);
            roomItem.appendChild(actionButtonsDiv);

            // Attach click listener to the whole room item (excluding action buttons)
            roomItem.addEventListener('click', () => switchRoom(room.id, room.name));

            // Update active state
            if (room.id === currentRoomId) {
                roomItem.classList.add('active');
            } else {
                roomItem.classList.remove('active');
            }
        }

        async function editRoomName(roomId, currentName) {
            const newName = prompt(`Enter new name for room "${currentName}":`, currentName);
            if (newName !== null && newName.trim() !== '' && newName !== currentName) {
                try {
                    await database.ref(`rooms/${roomId}`).update({ name: newName });
                    alert(`Room name updated to "${newName}".`);
                } catch (error) {
                    console.error("Error updating room name:", error);
                    alert("Failed to update room name.");
                }
            }
        }

        async function deleteRoom(roomId, roomName) {
            if (confirm(`Are you sure you want to delete the room "${roomName}" and all its messages? This cannot be undone.`)) {
                try {
                    await database.ref(`rooms/${roomId}`).remove();
                    alert(`Room "${roomName}" deleted.`);
                    // If the deleted room was the current room, switch to public
                    if (currentRoomId === roomId) {
                        switchRoom('public_channel', 'üåê Public Channel');
                    }
                    // The 'child_removed' listener in fetchAndDisplayRooms will handle updating the UI
                } catch (error) {
                    console.error("Error deleting room:", error);
                    alert("Failed to delete room.");
                }
            }
        }

async function switchRoom(newRoomId, newRoomName) {
    console.log("System: Starting switch to " + newRoomName);
   
    try {
        // 1. Cleanup old listeners
        if (messagesRef) messagesRef.off();
        if (presenceRef) presenceRef.off();

        // 2. Update UI State
        currentRoomId = newRoomId;
        currentRoomNameElem.textContent = newRoomName;
        messagesContainer.innerHTML = 'Loading messages...';
        cancelReply();

        // 3. Set Firebase References
        currentRoomRef = database.ref('rooms/' + newRoomId);
        messagesRef = currentRoomRef.child('messages');
        presenceRef = currentRoomRef.child('presence');

        // 4. Presence Logic (Using the sanitized currentUser)
        if (currentUser) {
            const userPresenceRef = presenceRef.child(currentUser);
            userPresenceRef.set(true);
            userPresenceRef.onDisconnect().remove();
        }

        // 5. Update Online Count UI
        presenceRef.on('value', snapshot => {
            const onlineUsers = snapshot.val();
            const count = onlineUsers ? Object.keys(onlineUsers).length : 0;
            onlineUsersCountElem.textContent = `Online: ${count}`;
        });

        // 6. INITIAL LOAD: Fetch all existing messages once
        messagesRef.once('value').then(snapshot => {
            messagesContainer.innerHTML = '';
            if (snapshot.exists()) {
                snapshot.forEach(childSnapshot => {
                    const msgElem = createMessageElement(childSnapshot.key, childSnapshot.val());
                    messagesContainer.appendChild(msgElem);
                });
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            } else {
                messagesContainer.innerHTML = '';
            }
        });

        // 7. LIVE LISTENERS: Watch for new, changed, or deleted messages
messagesRef.on('child_added', snapshot => {
    // 1. Define 'data' right at the start
    const data = snapshot.val();
    const messageId = snapshot.key;

    if (!document.querySelector(`[data-id="${messageId}"]`)) {
        const messageElem = createMessageElement(messageId, data);
        messagesContainer.appendChild(messageElem);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        // --- TITLE NOTIFICATION LOGIC ---
        // We use 'data' here, which we just defined above
        if (data.sender !== currentUser && document.hidden) {
            unreadCount++;
            document.title = `(${unreadCount}) ${originalTitle}`;
           
            const sound = document.getElementById('notif-sound');
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(e => console.log("Sound interaction required"));
            }
        }
    }
});

        messagesRef.on('child_changed', snapshot => {
            const existing = document.querySelector(`[data-id="${snapshot.key}"]`);
            if (existing) {
                const updated = createMessageElement(snapshot.key, snapshot.val());
                existing.replaceWith(updated);
            }
        });

        // --- Typing Indicator Listener ---
const typingRef = currentRoomRef.child('typing');

typingRef.on('value', snapshot => {
    // 1. ADD THIS LINE:
    const indicator = document.getElementById('typing-indicator');
   
    const usersTyping = snapshot.val() || {};
    const typers = Object.keys(usersTyping).filter(user => user !== currentUser);
   
    // 2. Now 'indicator' is defined and this will work:
    if (typers.length > 0) {
        const names = typers.join(', ');
        const grammar = typers.length > 1 ? " are typing" : " is typing";
       
        indicator.innerHTML = `
            ${names}${grammar}
            <span class="typing-dots">
                <span>.</span><span>.</span><span>.</span>
            </span>
        `;
    } else {
        indicator.innerHTML = "";
    }
});
        // --- THIS PART FIXES THE DELETE GLITCH ---
        messagesRef.on('child_removed', snapshot => {
            const messageId = snapshot.key;
            console.log("Removing deleted message: " + messageId);
            const existing = document.querySelector(`[data-id="${messageId}"]`);
            if (existing) {
                existing.remove();
            }
        });

    } catch (error) {
        console.error("Critical error in switchRoom:", error);
    }
}
    window.addEventListener('focus', () => {
    // This regex looks for "(any number)" followed by a space at the start of the title
    // and replaces it with nothing.
    document.title = document.title.replace(/^\(\d+\)\s?/, "");
});
        // === Event Listeners ===
        messageInput.addEventListener('input', () => {
    if (!currentUser) return;

    // Tell Firebase we are typing
    const myTypingRef = database.ref(`rooms/${currentRoomId}/typing/${currentUser}`);
    myTypingRef.set(true);

    // Clear the existing timeout
    clearTimeout(typingTimeout);

    // If user stops typing for 3 seconds, remove the indicator
    typingTimeout = setTimeout(() => {
        myTypingRef.remove();
    }, 1000);
});
        createRoomForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const roomName = newRoomNameInput.value.trim();
            if (roomName) {
                const newRoomRef = database.ref('rooms').push();
                const joinCode = generateJoinCode();
                const roomId = newRoomRef.key;
                await newRoomRef.set({
                    id: roomId,
                    name: roomName,
                    type: 'private',
                    joinCode: joinCode,
                    owner: currentUser, // NEW: Store the owner
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                });
                // Add the creator as a member of the private room
                await database.ref(`rooms/${roomId}/members/${currentUser}`).set(true);

                newRoomNameInput.value = '';
                alert(`Private room "${roomName}" created! Join code: ${joinCode}`);
                // fetchAndDisplayRooms() will re-run and add it
                switchRoom(roomId, roomName); // Switch to the newly created room
            }
        });

        joinRoomForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const code = joinRoomCodeInput.value.trim().toUpperCase();
            if (code) {
                const roomsSnapshot = await database.ref('rooms').orderByChild('joinCode').equalTo(code).once('value');
                const rooms = roomsSnapshot.val();
                if (rooms) {
                    const roomId = Object.keys(rooms)[0];
                    const roomData = rooms[roomId];
                   
                    // Add the joining user as a member
                    await database.ref(`rooms/${roomId}/members/${currentUser}`).set(true);

                    alert(`Joined private room: ${roomData.name}`);
                    joinRoomCodeInput.value = '';
                    fetchAndDisplayRooms(); // Refresh room list after joining
                    switchRoom(roomId, roomData.name); // Switch to the joined room
                } else {
                    alert('Invalid join code.');
                }
            }
        });

sendButton.addEventListener('click', async () => {
    const messageText = messageInput.value.trim();
    if (!messageText) return;

    // 1. Handle Secret Admin Commands (/mute, /clear)
    if (handleSecretCommands(messageText)) {
        messageInput.value = '';
        return;
    }

    // 2. THE GATEKEEPER: Check if the Hardware ID is muted
    if (!deviceFingerprint) {
        alert("Security ID loading... please wait a moment.");
        return;
    }

    database.ref('hardware_mutes/' + deviceFingerprint).once('value').then(async (snap) => {
        const muteData = snap.val();
        const now = Date.now();

        if (muteData && now < muteData.expiry) {
            // STOP: User is muted
            const minsLeft = Math.ceil((muteData.expiry - now) / 60000);
            alert("ACCESS DENIED: You are hardware muted for " + minsLeft + " more minutes.");
            messageInput.value = '';
        } else {
            // GO: User is allowed to speak
            const newMessage = {
                sender: currentUser,
                text: messageText,
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                edited: false
            };

            // Remove typing indicator on send
            database.ref(`rooms/${currentRoomId}/typing/${currentUser}`).remove();
            clearTimeout(typingTimeout);

            // Handle Replies
            if (replyingToMessage) {
                newMessage.replyToMessageId = replyingToMessage.id;
                newMessage.replyToMessageSender = replyingToMessage.sender;
                newMessage.replyToMessageText = replyingToMessage.text;
            }

            try {
                await messagesRef.push(newMessage);
                messageInput.value = '';
                cancelReply(); // Clear reply context
            } catch (error) {
                console.error("Error sending message:", error);
                alert("Failed to send message.");
            }
        }
    });
});

        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) { // Send on Enter, allow Shift+Enter for newline
                e.preventDefault();
                sendButton.click();
            }
        });

        cancelReplyButton.addEventListener('click', cancelReply);

        // === Initialization ===
        async function fetchAndDisplayRooms() {
            // First, detach any existing listeners on the rooms reference
            if (roomsListenerRef) {
                roomsListenerRef.off();
            }
            roomListElem.innerHTML = ''; // Clear existing rooms to avoid duplicates on refresh
            roomElements.clear(); // Clear the map of stored room elements

            const publicChannelId = 'public_channel';
            const publicChannelRef = database.ref(`rooms/${publicChannelId}`);
            const publicChannelSnapshot = await publicChannelRef.once('value');
            if (!publicChannelSnapshot.exists() || !publicChannelSnapshot.val().name) {
                await publicChannelRef.set({
                    id: publicChannelId,
                    name: 'üåê Public Channel',
                    type: 'public',
                    owner: 'system', // Public channel has a system owner
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                });
            }
            // Always display the public channel
            createOrUpdateRoomElement({ id: publicChannelId, name: 'üåê Public Channel', type: 'public', owner: 'system' });

            // Now, set up the listener for other rooms and store its reference
            roomsListenerRef = database.ref('rooms').orderByChild('createdAt');
            roomsListenerRef.on('child_added', async snapshot => {
                const room = snapshot.val();
               
                if (!room || !room.id || !room.name) {
                    console.warn("Invalid room data encountered:", room);
                    return;
                }

                if (room.id === publicChannelId) {
                    return; // Public channel is already displayed
                }

                if (room.type === 'private') {
                    // Check if current user is a member of this private room
                    const memberSnapshot = await database.ref(`rooms/${room.id}/members/${currentUser}`).once('value');
                    if (memberSnapshot.exists() && memberSnapshot.val() === true) {
                        createOrUpdateRoomElement(room);
                    }
                } else {
                    // For any other room type (e.g., future public rooms, though currently only one public)
                    createOrUpdateRoomElement(room);
                }
            });

            roomsListenerRef.on('child_changed', async snapshot => {
                const room = snapshot.val();
                 if (!room || !room.id || !room.name) {
                    console.warn("Invalid room data changed:", room);
                    return;
                }
                // If it's a private room, re-check membership before updating display
                if (room.type === 'private') {
                    const memberSnapshot = await database.ref(`rooms/${room.id}/members/${currentUser}`).once('value');
                    if (memberSnapshot.exists() && memberSnapshot.val() === true) {
                        createOrUpdateRoomElement(room);
                    } else {
                        // If user is no longer a member, remove from list
                        const roomElement = roomElements.get(room.id);
                        if (roomElement) {
                            roomElement.remove();
                            roomElements.delete(room.id);
                        }
                    }
                } else {
                    createOrUpdateRoomElement(room);
                }
            });
            // Listener for rooms being removed
            roomsListenerRef.on('child_removed', snapshot => {
                const roomRemovedId = snapshot.key;
                const roomElement = roomElements.get(roomRemovedId);
                if (roomElement) {
                    roomElement.remove(); // Remove from DOM
                    roomElements.delete(roomRemovedId); // Remove from map
                }
                // If the deleted room was the current room, switch to public
                if (currentRoomId === roomRemovedId) {
                    switchRoom(publicChannelId, 'üåê Public Channel');
                }
            });
        }


window.onload = async () => {

    // 1Ô∏è‚É£ WAIT for username (THIS FIXES EVERYTHING)
    currentUser = await getOrCreateUsername();

    if (!currentUser) return; // Stop if access denied

    usernameDisplay.textContent = `Username: ${currentUser}`;

    // 2Ô∏è‚É£ Restore admin UI properly
    if (localStorage.getItem('isAdmin') === 'true') {
        const isProtected = PROTECTED_NAMES.some(
            n => n.toLowerCase() === currentUser.toLowerCase()
        );

        if (isProtected) {
            userPrivileges = "admin";
            const toolbar = document.getElementById('admin-toolbar');
            if (toolbar) toolbar.style.display = 'block';
            console.log("Admin session restored.");
        } else {
            localStorage.removeItem('isAdmin');
            userPrivileges = "normal";
        }
    }

    // 3Ô∏è‚É£ Start fingerprint AFTER username exists
    startFingerprint();

    // 4Ô∏è‚É£ Initialize rooms AFTER username is ready
    setTimeout(async () => {

        console.log("System: Initializing Room Display...");
        await fetchAndDisplayRooms();

        console.log("System: Joining Public Channel...");
        await switchRoom('public_channel', 'üåê Public Channel');

        checkMuteStatus();

    }, 500);
};

        // Add this to your send
    </script>
    <script src="about.js"></script>
<script src="era4.js"></script>
<script src="era5.js"></script>
<script src="pe.js"></script>
<script src="warn.js"></script>
<script src="cursor.js"></script>
<script rc="widget.js"></script>

</body>
</html>
